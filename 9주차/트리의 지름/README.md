# 문제: [트리의 지름][link]

[link]: https://www.acmicpc.net/problem/1967

### 출제자 : 최은우

---
### 풀이법 : 

## 트리

문제는 트리라고만 지정했지 이진트리라고는 안했다.  
고로 한 부모로부터 0개부터 n개까지 여러 수의 자식 노드가 나타날 수 있다는점 유의하자

## 각 노드마다의 지름

말이 제일 긴 지름이지 어떤 하나의 노드를 루트로 지정하여 제일 긴 노드의 연결을 구하는것과 다름 없다.  
예제 입력을 두고 하나의 visit 배열을 만들어보자

|인덱스 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 | 11|12 |
|------ |---|---|---|---|---|---|---|---|---|---|---|---|---|
|지름   | 0 | 43| 12| 45| 8 | 19| 16| 0 | 0 | 0 | 0 | 0 | 0 |

해당 표의 의미를 이해할 수 있어야 한다  
각 노드를 루트로 잡았을때 제일 길게 만들 수 있는 노드의 연결을 구한 것이다.

저 값에서 최대값을 구하게되면 원하는 출력이 나오게 된다.

## dfs

각 노드마다의 지름을 구하는것을 알았고 이제는 어떻게 구해야하는지를 알아야 한다.  
1 3 2 와 1 2 3 을 보자  
1번 노드의 지름을 구하려면 
1번과 2번노드의 길이 + 2번노드까지의 제일 긴 연결선 +  
1번과 3번노드의 길이 + 3번노드까지의 제일 긴 연결선  
을 구해야 하고 우리는 각 노드사이의 길이는 이미 알고있기 때문에 **제일 긴 연결선** 을 dfs로 구하면 된다는 말이 된다.

추가로 dfs로 각 노드를 방문하기 때문에 방문과 동시에 visit배열에 값을 채워넣으면 된다.

그럼과 동시에 제일 중요한 이 트리는 이진트리가 아니므로 자식이 여럿이 나올 수 있다.  
특정 노드 n 을 중심으로 k개의 자식이 있다면 결국 그 중 제일 긴 2개의 길이를 선택하여야 하고  
만약 위 1번 노드에서 13번 노드의 연결이 길이가 100으로 있다고 했을시  
1-13 + 1-3 의 길이가 되어 128이 나와야 할것이다


## 간단 풀이

예제의 값으로 부모 : [[자식, 비용],...] 형식의  map을 만들어준다  
```
{
  '1': [ [ 2, 3 ], [ 3, 2 ] ],
  '2': [ [ 4, 5 ] ],
  '3': [ [ 5, 11 ], [ 6, 9 ] ],
  '4': [ [ 7, 1 ], [ 8, 7 ] ],
  '5': [ [ 9, 15 ], [ 10, 4 ] ],
  '6': [ [ 11, 6 ], [ 12, 10 ] ]
}
```

dfs의 내부 코드는 다음과 같이 구현한다

```
visit = Array(n+1).fill(0) // 0번째 인덱스때문에 12개까지 입력받으려면 13개를 초기화 해야함

dfs(current){
  if(map[current]){ // 자식 노드가 있는 경우
    lengths=[0] // 자식 노드가 1개일 경우 2개를 더해야하는데 어차피 한쪽은 0이기에 0을 먼저 넣어준다
    nodes = map[current]
    for(node in nodes){
      next = node[0]
      cost = node[1]
      lengths.push(dfs(next) + cost) // dfs 순환
    }
    lengths.sort((a,b)=>b-a) // 내림차순 정렬
    visit[current] = lengths[0] + lengths[1] // 제일 긴 두 길이를 더하여 visit에 넣고
    return lengths[0] // 제일 긴 길이를 반환
  }else { // 자식 노드가 없는경우 
    return 0
  }
}
```