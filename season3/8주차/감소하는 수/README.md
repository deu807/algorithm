# 문제: [감소하는 수][link]

[link]: https://www.acmicpc.net/problem/1038

### 출제자 : 오민경

---

### 풀이법 : 

조건1 : 가장 큰 자릿수부터 작은 자릿수까지 숫자가 감소한다.
조건2 : 한 자리 숫자는 그 자체로 감소하는 수이다. ex. 0 : 0번째 감소하는 수, 1 : 1번째 감소하는 수 ...

한 자리 수 : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 
두 자리 수 : 10, 20, 21, 30, 31, 32 ... 98
세 자리 수 : 210, 310, 320, 321 ... 987
...
열 자리 수 : 9876543210

두 가지 방법이 존재
1. 뒤에 감소하는 수를 넣기 ex. 2를 기준으로 뒤에 0과 1을 넣을 수 있음
2. 앞에 더 큰 수를 넣기 ex. 2를 기준으로 앞에 3~9까지의 숫자를 넣을 수 있음

1번 방법을 사용하여 문제를 풂
하나의 숫자에서 파생되는 감소하는 수가 여러가지이기 때문에 BFS를 이용 - 큐 사용

0~9는 그 숫자 자체로 감소하는 수이므로 큐와 배열에 저장
이 때, 배열은 모든 감소하는 수를 저장하고 큐는 n자리 수에서 나올 수 있는 수를 pop하여 n+1자리 감소하는 수들을 넣기 위해 사용 -> 계속해서 반복되고 큐가 empty상태(더이상 감소하는 수가 없을 때, 범위 초과)가 되면 반복 종료

세 자리 수(n+1)의 경우를 살펴보면
두 자리 수(n)인 10은 마지막 자리의 수가 0으로 더이상 감소하는 수가 없으므로 제외하고
20도 같은 경우로 제외하고, 21은 그 다음으로 0이 올 수 있으므로 210을 큐와 배열에 저장
마지막 자리 수를 구하기 위해서 %(나머지)연산자를 사용

입력받은 수만큼 반복해주면 되는데, 배열을 모두 0으로 초기화하고
index를 9로 설정하고 입력받은 N이 될때까지 반복문을 수행
만약 값을 초과하면 !arr[N]이 1가 되기 때문에 if문을 이용하여 -1를 출력해줌
0을 입력했을 때도 -1이 되는 경우가 발생할 수 있으므로 한 자리 숫자를 입력받으면 바로 숫자를 출력